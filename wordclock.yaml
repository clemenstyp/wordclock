substitutions:
  led_pin: GPIO0
  i2c_scl_pin: GPIO1
  i2c_sda_pin: GPIO2

esphome:
  on_boot:
    - priority: 600
      then:
      # read the RTC time once when the system boots
        - ds1307.read_time:
           id: ds1307_time
    - priority: 780
      then:
        - light.turn_on: word_clock

# example boot priority:
# 800.0: This is where all hardware initialization of vital components is executed. For example setting switches to their initial state.
# 600.0: This is where most sensors are set up.
# 250.0: At this priority, WiFi is initialized.
# 200.0: Network connections like MQTT/native API are set up at this priority.
# -100.0: At this priority, pretty much everything should already be initialized.


      
# used for ds1307 i2c
# sda kann auch GPIO4 sein
# scl kann auch GPIO5 sein 
i2c:
  sda: ${i2c_sda_pin}
  scl: ${i2c_scl_pin}
  scan: false
  id: i2c_bus

time:
  - platform: ds1307
    # repeated synchronization is not necessary unless the external RTC
    # is much more accurate than the internal clock
    update_interval: never
    id: ds1307_time
    i2c_id: i2c_bus
    timezone: 'Europe/Berlin'
    address: 0x68
    on_time:
      # Every 1 minutes
      - seconds: 0
        minutes: /1
        then:
          - script.execute: 
              id: set_auto_brightness
              transition_length: 10000
  - platform: sntp
    # instead try to synchronize via network repeatedly ...
    id: sntp_time
    timezone: 'Europe/Berlin'
    servers:
     - 0.pool.ntp.org
     - 1.pool.ntp.org
     - 2.pool.ntp.org
    on_time_sync:
      then:
        # ... and update the RTC when the synchronization was successful
        ds1307.write_time:
          id: ds1307_time

globals:
  - id: time_offset
    type: int
    restore_value: yes
    initial_value: '0'


switch:
  - platform: template
    name: "Manual Time"
    id: manual_time
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    web_server: { sorting_weight: 30, sorting_group_id: "sorting_group_extra_settings" }
    icon: "mdi:clock-edit-outline"
  - platform: template
    name: "Automatic Brightness"
    id: automatic_brightness
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:brightness-auto"
    web_server: { sorting_weight: 10, sorting_group_id: "sorting_group_dnd_settings" }
  - platform: template
    name: "Indication: It is"
    id: indication_it_is
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:file-word-box-outline"
    web_server: { sorting_weight: 10, sorting_group_id: "sorting_group_extra_settings" }
  - platform: template
    name: "Indication: Minutes"
    id: indication_minutes
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:file-word-box-outline"
    web_server: { sorting_weight: 11, sorting_group_id: "sorting_group_extra_settings" }
  - platform: template
    name: "Indication: Week Days"
    id: indication_week_days
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:file-word-box-outline"
    web_server: { sorting_weight: 12, sorting_group_id: "sorting_group_extra_settings" }

button:
  - platform: factory_reset
    id: factory_reset_button
    name: Factory Reset Word Clock
    web_server: { sorting_weight: 20, sorting_group_id: "sorting_group_advanced_settings" }
  - platform: restart
    id: restart_button
    name: Restart Word Clock
    web_server: { sorting_weight: 10, sorting_group_id: "sorting_group_advanced_settings" }

datetime:
  - platform: template
    id: current_datetime
    type: datetime
    name: Manual Time
    update_interval: 60s
    web_server: {sorting_weight: 31, sorting_group_id: "sorting_group_extra_settings" }
    lambda: |-
      int timestamp_with_offset = id(sntp_time).now().timestamp + int(id(time_offset));
      auto time = ESPTime::from_epoch_local(timestamp_with_offset);
      return time;
    set_action:
      - lambda: |-
          id(time_offset) = int(x.timestamp - id(sntp_time).now().timestamp);
    icon: "mdi:clock-edit-outline"
  - platform: template
    id: morning_transition_start_time
    type: time
    name: Morning Transition Start Time
    optimistic: yes
    initial_value: "06:00:00"
    restore_value: true
    web_server: { sorting_weight: 33, sorting_group_id: "sorting_group_dnd_settings" }   
    icon: "mdi:weather-sunset-up"
  - platform: template
    id: morning_transition_end_time
    type: time
    name: Morning Transition End Time
    optimistic: yes
    initial_value: "09:00:00"
    restore_value: true
    web_server: { sorting_weight: 34, sorting_group_id: "sorting_group_dnd_settings" }
    icon: "mdi:weather-sunny"
  - platform: template
    id: night_transition_start_time
    type: time
    name: Night Transition Start Time
    optimistic: yes
    initial_value: "18:00:00"
    restore_value: true
    web_server: { sorting_weight: 31, sorting_group_id: "sorting_group_dnd_settings" }
    icon: "mdi:weather-sunset-down"
  - platform: template
    id: night_transition_end_time
    type: time
    name: Night Transition End Time
    optimistic: yes
    initial_value: "22:00:00"
    restore_value: true
    web_server: { sorting_weight: 32, sorting_group_id: "sorting_group_dnd_settings" }
    icon: "mdi:weather-night"

script:
  - id: set_auto_brightness
    mode: single
    parameters: 
      transition_length: int
    then:
      - if: 
          condition:
            and: 
              - switch.is_on: automatic_brightness
          then:
            - light.control:
                id: word_clock
                transition_length: !lambda return transition_length;
                brightness: !lambda |-
                  float min_brightness = id(minimum_brightness).state;
                  float max_brightness = id(maximum_brightness).state;
                  float brightness = id(maximum_brightness).state;

                  int timestamp_with_offset = id(sntp_time).now().timestamp;
                  if (id(manual_time).state){
                    timestamp_with_offset +=  int(id(time_offset));
                  }
                  
                  auto time = ESPTime::from_epoch_local(timestamp_with_offset);
                  int time_minute_of_day = (time.hour * 60) + time.minute % 1440;
            
                  int morning_transition_start_minute_of_day = (id(morning_transition_start_time).hour * 60) + id(morning_transition_start_time).minute;
                  int morning_transition_end_minute_of_day = ( id(morning_transition_end_time).hour * 60) +  id(morning_transition_end_time).minute;
                  int night_transition_start_minute_of_day = (id(night_transition_start_time).hour * 60) + id(night_transition_start_time).minute;
                  int night_transition_end_minute_of_day = (id(night_transition_end_time).hour * 60) + id(night_transition_end_time).minute;


                  if (time_minute_of_day >= night_transition_end_minute_of_day || time_minute_of_day < morning_transition_start_minute_of_day) {
                    brightness = min_brightness;  // Low brightness at night
                  } else if (time_minute_of_day >= night_transition_start_minute_of_day ) {
                    // Calculate evening brightness based on time difference
                    float total_duration = float(night_transition_end_minute_of_day - night_transition_start_minute_of_day);
                    float time_passed = float(time_minute_of_day - night_transition_start_minute_of_day);    

                    brightness = max_brightness - ((max_brightness - min_brightness) * (time_passed / total_duration));  // Gradually decrease brightness
                  } else if (time_minute_of_day < morning_transition_end_minute_of_day) {
                    // Calculate evening brightness based on time difference
                    float total_duration = float(morning_transition_end_minute_of_day - morning_transition_start_minute_of_day);
                    float time_passed = float(time_minute_of_day - morning_transition_start_minute_of_day);
                                        
                    brightness = min_brightness + ((max_brightness - min_brightness) * (time_passed / total_duration));  // Gradually increse brightness
                  } 
                  return brightness;

number:
  - platform: template
    name: "Transition"
    id: transition
    optimistic: True
    min_value: 0
    max_value: 5
    initial_value: 0.5
    step: 0.5
    restore_value: True
    icon: "mdi:transition"
    web_server: { sorting_weight: 20, sorting_group_id: "sorting_group_main" }
  - platform: template
    name: "Minimum Brightness"
    id: minimum_brightness
    optimistic: True
    min_value: 0.0
    max_value: 1
    step: 0.01
    initial_value: 0.1
    restore_value: True
    icon: "mdi:brightness-4"
    web_server: { sorting_weight: 11, sorting_group_id: "sorting_group_dnd_settings" }
    on_value:
      - if: 
          condition:
            - lambda: "return id(maximum_brightness).state < x;"
          then:
            - number.set:
               id: maximum_brightness
               value: !lambda "return x;"
      - script.execute: 
          id: set_auto_brightness
          transition_length: 50
  - platform: template
    name: "Maximum Brightness"
    id: maximum_brightness
    optimistic: True
    min_value: 0.01
    max_value: 1
    initial_value: 1
    step: 0.01
    restore_value: True  
    icon: "mdi:brightness-5"
    web_server: { sorting_weight: 12, sorting_group_id: "sorting_group_dnd_settings" }
    on_value:
      - if: 
          condition:
            - lambda: "return x < id(minimum_brightness).state;"
          then:
            - number.set:
               id: minimum_brightness
               value: !lambda "return x;"
      - script.execute: 
          id: set_auto_brightness
          transition_length: 50

light:
  - platform: neopixelbus
    name: "Word Clock"
    id: word_clock
    type: GRB
    variant: WS2812X
    pin: $led_pin
    num_leds: 126 
    default_transition_length: 1s
    icon: "mdi:file-word-box-outline"
    restore_mode: RESTORE_DEFAULT_ON
    web_server: { sorting_weight: 10, sorting_group_id: "sorting_group_main" }
    on_state:
      then:
        - if:
            condition:
              and:
                - lambda: "return id(word_clock).get_effect_name() == \"None\";"
                - light.is_on: word_clock
            then:
              - delay: 10ms
              # Enforce the light effect to be at "ClockEffect"
              - light.control:
                  id: word_clock
                  effect: ClockEffect
    effects:
      - addressable_lambda:
          name: "ClockEffect"
          update_interval: 20ms
          lambda: |-
            static uint8_t previousMinutes;
            static Color letters[126];

            // LED IDs            
            //   110 | E S K I S T L F Ü N F | 120
            //   109 | Z E H N Z W A N Z I G |  99
            //   88  | D R E I V I E R T E L |  98
            //   87  | T G N A C H V O R J M |  77
            //   66  | H A L B X Z W Ö L F P |  76
            //   65  | Z W E I N S I E B E N |  55
            //   44  | K D R E I R H F Ü N F |  54
            //   43  | E L F N E U N V I E R |  33
            //   22  | W A C H T Z E H N R S |  32
            //   21  | B S E C H S F M U H R |  11
            //   0   | E V M D M D F S S P I |  10
            //   121 |       . . . . .       | 125 

            const uint8_t single_words[35][2] {
              {110,111}, // [0]  ES 
              {113,115}, // [1]  IST 
              { 11, 13}, // [2]  UHR
              { 82, 85}, // [3]  NACH
              { 79, 81}, // [4]  VOR
              {117,120}, // [5]  FÜNF
              {106,109}, // [6]  ZEHN
              { 92, 98}, // [7]  VIERTEL
              { 99,105}, // [8]  ZWANZIG 
              { 66, 69}, // [9]  HALB
              { 71, 75}, // [10] ZWÖLF
              { 60, 63}, // [11] EINS
              { 62, 65}, // [12] ZWEI
              { 45, 48}, // [13] DREI
              { 33, 36}, // [14] VIER
              { 51, 54}, // [15] FÜNF
              { 16, 20}, // [16] SECHS
              { 55, 60}, // [17] SIEBEN
              { 23, 26}, // [18] ACHT
              { 37, 40}, // [19] NEUN
              { 27, 30}, // [20] ZEHN
              { 41, 43}, // [21] ELF
              { 61, 63}, // [22] EIN
              {  8,  8}, // [23] - S (Sonntag)
              {  2,  2}, // [24] - M (Montag)
              {  3,  3}, // [25] - D (Dienstag)
              {  4,  4}, // [26] - M (Mittwoch)
              {  5,  5}, // [27] - D (Donnnerstag)
              {  6,  6}, // [28] - F (Freitag)
              {  7,  7}, // [29] - S (Samstag)
              {123,123}, // [30] - MIN 
              {124,124}, // [31] - MIN + 1
              {125,125}, // [32] - MIN + 2
              {121,122}, // [33] - MIN - 2
              {122,122}  // [34] - MIN - 1
            };


            if (initial_run) {
              it.all() = Color::BLACK;
              std::fill_n(letters, it.size(), Color::BLACK);
            }

            int timestamp_with_offset = id(sntp_time).now().timestamp;
            if (id(manual_time).state){
              timestamp_with_offset +=  int(id(time_offset));
            }
            
            auto time = ESPTime::from_epoch_local(timestamp_with_offset);
            
            // update letter array
            if (previousMinutes != time.minute) {
              std::fill_n(letters, it.size(), Color::BLACK);

              auto add_word = [&](int single_word_id) -> void {
                for (uint8_t i = single_words[single_word_id][0]; i <=  single_words[single_word_id][1]; i++) {
                  letters[i] = current_color;
                }
              };


              // show "es ist"
              if (id(indication_it_is).state) {
                add_word(0);
                add_word(1);
              } 
              
              // show weekday
              if (id(indication_week_days).state) {
                add_word(time.day_of_week + 22);
              }

              //show minutes
              if (id(indication_minutes).state) {
                add_word((time.minute % 5) + 30);
              } 

              if (time.minute <= 2 || time.minute >= 58){
                add_word(2);
              }else if (time.minute <= 7){
                add_word(5);
                add_word(3);
              }else if (time.minute <= 12){
                add_word(6);
                add_word(3);
              }else if (time.minute <= 17){
                add_word(7);
                add_word(3);
              }else if (time.minute <= 22){
                add_word(8);
                add_word(3);
              }else if (time.minute <= 27){
                add_word(5);
                add_word(4);
                add_word(9);
              }else if (time.minute <= 32){
                add_word(9);
              }else if (time.minute <= 37){
                add_word(5);
                add_word(3);
                add_word(9);
              }else if (time.minute <= 42){
                add_word(8);
                add_word(4);
              }else if (time.minute <= 47){
                add_word(7);
                add_word(4);
              }else if (time.minute <= 52){
                add_word(6);
                add_word(4);
              }else if (time.minute <= 57){
                add_word(5);
                add_word(4);
              }


              if ( ( time.minute <= 2 || time.minute >= 58 ) && ((time.hour % 12) == 1) ) {
                add_word(22);
              }else if (time.minute >= 23){ // für fünf vor halb...
                add_word(((time.hour +1 ) % 12) + 10);
              }else {
                add_word((time.hour % 12) + 10);
              } 

              previousMinutes = uint8_t(time.minute);
            }

            uint8_t fade_amount;
            if (id(transition).state == 0){
              fade_amount = 255;
            }else{
              fade_amount = uint8_t(25/id(transition).state); 
            }
            for (int i = 0; i < it.size(); i++) {
              it[i] = it[i].get().gradient(letters[i], fade_amount);              
            }

            // id(set_auto_brightness)->execute(500);

      # - addressable_lambda:
      #     name: "ClockEffect"
      #     update_interval: 20ms
      #     lambda: |-
      #       static uint8_t previousMinutes;
      #       static Color letters[126];

      #       // LED IDs            
      #       //   110 | E S K I S T L F Ü N F | 120
      #       //   109 | Z E H N Z W A N Z I G |  99
      #       //   88  | D R E I V I E R T E L |  98
      #       //   87  | T G N A C H V O R J M |  77
      #       //   66  | H A L B X Z W Ö L F P |  76
      #       //   65  | Z W E I N S I E B E N |  55
      #       //   44  | K D R E I R H F Ü N F |  54
      #       //   43  | E L F N E U N V I E R |  33
      #       //   22  | W A C H T Z E H N R S |  32
      #       //   21  | B S E C H S F M U H R |  11
      #       //   0   | E V M D M D F S S P I |  10
      #       //   121 |       . . . . .       | 125 

      #       const uint8_t single_words[35][2] {
      #         {110,111}, // [0]  ES 
      #         {113,115}, // [1]  IST 
      #         { 11, 13}, // [2]  UHR
      #         { 82, 85}, // [3]  NACH
      #         { 79, 81}, // [4]  VOR
      #         {117,120}, // [5]  FÜNF
      #         {106,109}, // [6]  ZEHN
      #         { 92, 98}, // [7]  VIERTEL
      #         { 99,105}, // [8]  ZWANZIG 
      #         { 66, 69}, // [9]  HALB
      #         { 71, 75}, // [10] ZWÖLF
      #         { 60, 63}, // [11] EINS
      #         { 62, 65}, // [12] ZWEI
      #         { 45, 48}, // [13] DREI
      #         { 33, 36}, // [14] VIER
      #         { 51, 54}, // [15] FÜNF
      #         { 16, 20}, // [16] SECHS
      #         { 55, 60}, // [17] SIEBEN
      #         { 23, 26}, // [18] ACHT
      #         { 37, 40}, // [19] NEUN
      #         { 27, 30}, // [20] ZEHN
      #         { 41, 43}, // [21] ELF
      #         { 61, 63}, // [22] EIN
      #         {  8,  8}, // [23] - S (Sonntag)
      #         {  2,  2}, // [24] - M (Montag)
      #         {  3,  3}, // [25] - D (Dienstag)
      #         {  4,  4}, // [26] - M (Mittwoch)
      #         {  5,  5}, // [27] - D (Donnnerstag)
      #         {  6,  6}, // [28] - F (Freitag)
      #         {  7,  7}, // [29] - S (Samstag)
      #         {123,123}, // [30] - MIN 
      #         {124,124}, // [31] - MIN + 1
      #         {125,125}, // [32] - MIN + 2
      #         {121,122}, // [33] - MIN - 2
      #         {122,122}  // [34] - MIN - 1
      #       };


      #       if (initial_run) {
      #         it.all() = Color::BLACK;
      #         std::fill_n(letters, it.size(), Color::BLACK);
      #       }

      #       int timestamp_with_offset = id(sntp_time).now().timestamp;
      #       if (id(manual_time).state){
      #         timestamp_with_offset +=  int(id(time_offset));
      #       }
            
      #       auto time = ESPTime::from_epoch_local(timestamp_with_offset);
            
      #       // update letter array
      #       if (previousMinutes != time.minute) {
      #         signed char shown_words[8] = {-1,-1,-1,-1,-1,-1,-1,-1,};
      #         std::fill_n(letters, it.size(), Color::BLACK);

      #         signed char iterator = 0;

      #         // show "es ist"
      #         if (id(indication_it_is).state) {
      #           shown_words[iterator++] = 0;
      #           shown_words[iterator++] = 1;
      #         }  // max iterator = 2
              
      #         // show weekday
      #         if (id(indication_week_days).state) {
      #           shown_words[iterator++] = time.day_of_week + 22;
      #         }  // max iterator = 3

      #         //show minutes
      #         if (id(indication_minutes).state) {
      #           shown_words[iterator++] = (time.minute % 5) + 30;
      #         }  // max iterator = 4

      #         if (time.minute <= 2 || time.minute >= 58){
      #           shown_words[iterator++] = 2;
      #         }else if (time.minute <= 7){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 12){
      #           shown_words[iterator++] = 6;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 17){
      #           shown_words[iterator++] = 7;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 22){
      #           shown_words[iterator++] = 8;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 27){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 4;
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 32){
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 37){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 3;
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 42){
      #           shown_words[iterator++] = 8;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 47){
      #           shown_words[iterator++] = 7;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 52){
      #           shown_words[iterator++] = 6;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 57){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 4;
      #         }  // max iterator = 7


      #         if ( ( time.minute <= 2 || time.minute >= 58 ) && ((time.hour % 12) == 1) ) {
      #           shown_words[iterator++] = 22;
      #         }else if (time.minute >= 23){ // für fünf vor halb...
      #           shown_words[iterator++] = static_cast<signed char>(((time.hour +1 ) % 12) + 10);
      #         }else {
      #           shown_words[iterator++] = static_cast<signed char>((time.hour % 12) + 10);
      #         } // max iterator = 8

      #         iterator = -1;
      #         for (uint8_t i = 0; i < 8; i++){
      #           if (shown_words[i] >= 0){
      #             for (iterator = single_words[shown_words[i]][0]; iterator <=  single_words[shown_words[i]][1]; iterator++) {
      #               letters[iterator] = current_color;
      #             }
      #           }
                
      #         }
      #         previousMinutes = uint8_t(time.minute);
      #       }

      #       uint8_t fade_amount;
      #       if (id(transition).state == 0){
      #         fade_amount = 255;
      #       }else{
      #         fade_amount = uint8_t(25/id(transition).state); 
      #       }
      #       for (int i = 0; i < it.size(); i++) {
      #         it[i] = it[i].get().gradient(letters[i], fade_amount);              
      #       }

      #       // id(set_auto_brightness)->execute(500);
      # - addressable_lambda:
      #     name: "ClockEffect"
      #     update_interval: 20ms
      #     lambda: |-
      #       static int previousMinutes;
      #       static int currentFade;
      #       static int fadeTransition;

      #       // LED IDs            
      #       //   110 | E S K I S T L F Ü N F | 120
      #       //   109 | Z E H N Z W A N Z I G |  99
      #       //   88  | D R E I V I E R T E L |  98
      #       //   87  | T G N A C H V O R J M |  77
      #       //   66  | H A L B X Z W Ö L F P |  76
      #       //   65  | Z W E I N S I E B E N |  55
      #       //   44  | K D R E I R H F Ü N F |  54
      #       //   43  | E L F N E U N V I E R |  33
      #       //   22  | W A C H T Z E H N R S |  32
      #       //   21  | B S E C H S F M U H R |  11
      #       //   0   | E V M D M D F S S P I |  10
      #       //   121 |       . . . . .       | 125 

      #       static Color letters[126];
      #       const signed char single_words[35][2] {
      #         {110,111}, // [0]  ES 
      #         {113,115}, // [1]  IST 
      #         { 11, 13}, // [2]  UHR
      #         { 82, 85}, // [3]  NACH
      #         { 79, 81}, // [4]  VOR
      #         {117,120}, // [5]  FÜNF
      #         {106,109}, // [6]  ZEHN
      #         { 92, 98}, // [7]  VIERTEL
      #         { 99,105}, // [8]  ZWANZIG 
      #         { 66, 69}, // [9]  HALB
      #         { 71, 75}, // [10] ZWÖLF
      #         { 60, 63}, // [11] EINS
      #         { 62, 65}, // [12] ZWEI
      #         { 45, 48}, // [13] DREI
      #         { 33, 36}, // [14] VIER
      #         { 51, 54}, // [15] FÜNF
      #         { 16, 20}, // [16] SECHS
      #         { 55, 60}, // [17] SIEBEN
      #         { 23, 26}, // [18] ACHT
      #         { 37, 40}, // [19] NEUN
      #         { 27, 30}, // [20] ZEHN
      #         { 41, 43}, // [21] ELF
      #         { 61, 63}, // [22] EIN
      #         {  8,  8}, // [23] - S (Sonntag)
      #         {  2,  2}, // [24] - M (Montag)
      #         {  3,  3}, // [25] - D (Dienstag)
      #         {  4,  4}, // [26] - M (Mittwoch)
      #         {  5,  5}, // [27] - D (Donnnerstag)
      #         {  6,  6}, // [28] - F (Freitag)
      #         {  7,  7}, // [29] - S (Samstag)
      #         {123,123}, // [30] - MIN 
      #         {124,124}, // [31] - MIN + 1
      #         {125,125}, // [32] - MIN + 2
      #         {121,122}, // [33] - MIN - 2
      #         {122,122}  // [34] - MIN - 1
      #       };


      #       if (initial_run) {
      #         it.all() = Color::BLACK;
      #         std::fill_n(letters, it.size(), Color::BLACK);
      #         currentFade = int(25*id(transition).state);
      #         fadeTransition = int(25*id(transition).state);
      #       }
            
      #       /*
      #        * Below is the transition control of the clock to change to the next time (next 5 minute section).
      #        * The update_interval is 20ms, which would mean that it takes 50 iterations in total to fade to the next time over a 1 second period.
      #        * This fade is divided into fading-out the old time (25 steps) and fading-in the new time (25 steps).
      #        * The transition slider specifies the number of seconds the total fade takes (id: transition).
      #        * The value of the transition is multiplied by 25 (steps) to create the fader.
      #        */
      #       auto trans = int(25*id(transition).state);
      #       if (trans != fadeTransition) {
      #         currentFade = trans;
      #         fadeTransition = trans;
      #       }

      #       int timestamp_with_offset = id(sntp_time).now().timestamp;
      #       if (id(manual_time).state){
      #         timestamp_with_offset +=  int(id(time_offset));
      #       }
            
      #       auto time = ESPTime::from_epoch_local(timestamp_with_offset);
            
      #       if (!initial_run) {
      #         /*
      #         for (int i = 0; i < it.size(); i++) {
      #             if (letters[i] == Color::BLACK && it[i] != Color::BLACK){
      #               it[i].fade_to_black(50);
      #             }
      #         }
      #         */

      #         // Fade words from selected brightness down to zero, when time changes.
      #         if (previousMinutes != time.minute && currentFade > 0) {
      #           for (int i = 0; i < it.size(); i++) {
      #             it[i] = Color(int(letters[i].r*currentFade/fadeTransition), int(letters[i].g*currentFade/fadeTransition), int(letters[i].b*currentFade/fadeTransition));
      #           }
      #           currentFade--;
      #           return;
      #         }

      #         // Set previous time to current time, such that above code will not run again. 
      #         previousMinutes = time.minute;
      #       }


      #       if (previousMinutes == time.minute) {
      #         signed char shown_words[8] = {-1,-1,-1,-1,-1,-1,-1,-1,};
      #         std::fill_n(letters, it.size(), Color::BLACK);

      #         signed char iterator = 0;

      #         // show "es ist"
      #         if (id(indication_it_is).state) {
      #           shown_words[iterator++] = 0;
      #           shown_words[iterator++] = 1;
      #         }  // max iterator = 2
              
      #         // show weekday
      #         if (id(indication_week_days).state) {
      #           shown_words[iterator++] = time.day_of_week + 22;
      #         }  // max iterator = 3

      #         //show minutes
      #         if (id(indication_minutes).state) {
      #           shown_words[iterator++] = (time.minute % 5) + 30;
      #         }  // max iterator = 4

      #         if (time.minute <= 2 || time.minute >= 58){
      #           shown_words[iterator++] = 2;
      #         }else if (time.minute <= 7){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 12){
      #           shown_words[iterator++] = 6;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 17){
      #           shown_words[iterator++] = 7;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 22){
      #           shown_words[iterator++] = 8;
      #           shown_words[iterator++] = 3;
      #         }else if (time.minute <= 27){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 4;
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 32){
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 37){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 3;
      #           shown_words[iterator++] = 9;
      #         }else if (time.minute <= 42){
      #           shown_words[iterator++] = 8;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 47){
      #           shown_words[iterator++] = 7;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 52){
      #           shown_words[iterator++] = 6;
      #           shown_words[iterator++] = 4;
      #         }else if (time.minute <= 57){
      #           shown_words[iterator++] = 5;
      #           shown_words[iterator++] = 4;
      #         }  // max iterator = 7


      #         if ( ( time.minute <= 2 || time.minute >= 58 ) && ((time.hour % 12) == 1) ) {
      #           shown_words[iterator++] = 22;
      #         }else if (time.minute >= 23){ // für fünf vor halb...
      #           shown_words[iterator++] = static_cast<signed char>(((time.hour +1 ) % 12) + 10);
      #         }else {
      #           shown_words[iterator++] = static_cast<signed char>((time.hour % 12) + 10);
      #         } // max iterator = 8

      #         iterator = -1;
      #         for (signed char i = 0; i < 8; i++){
      #           if (shown_words[i] >= 0){
      #             for (iterator = single_words[shown_words[i]][0]; iterator <=  single_words[shown_words[i]][1]; iterator++) {
      #               letters[iterator] = current_color;
      #             }
      #           }
                
      #         }
      #       }

      #       if (!initial_run) {
      #         // Now that new pixels for current time are known, slowly fade in the words.
      #         if (currentFade < fadeTransition) {
      #           for (int i = 0; i < it.size(); i++) it[i] = Color(int(letters[i].r*currentFade/fadeTransition), int(letters[i].g*currentFade/fadeTransition), int(letters[i].b*currentFade/fadeTransition));
      #           currentFade++;
      #           return;
      #         }
      #       }
              
      #       for (int i = 0; i < it.size(); i++) {
      #         it[i] = letters[i];
      #       }
      #       // Set previous time to current time, such that above code will not run again. 
      #       previousMinutes = time.minute;